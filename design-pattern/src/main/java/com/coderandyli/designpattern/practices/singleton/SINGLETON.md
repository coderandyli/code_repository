## 单例模式

序号 | 模式 | 是否延迟初始化 | 是否线程安全  |描述 | 适用场景
--- | --- | --- | --- | --- | ---
1 | 饱汉模式，线程不安全 | 是 | 否 | 实现简单，不能在多线程下工作 | 适用单线程环境下
2 | 饱汉模式，线程安全 | 是 | 是 | 效率低，加锁影响效率；能在多线程下工作 | 适用于对适用不太频繁的多线程环境下
3 | 饱汉模式，双重校验锁 （DCL, double-checked locking）| 是 | 是 | 安全且多线程环境下保持高性能
4 | 饿汉模式 | 否 | 是 | 无锁，执行效率高；类加载时就初始化，并没有达到lazy loading(懒加载)的效果，浪费内存  |  不推荐适用（IDEA单例模式的实现方式）
5 | Folder模式 | 是 | 是 | 无锁，线程安全 |



## 单例模式与静态类
```
 1. 首先明确一下，静态成员并不是什么程序加载时创建并初始化的，而是类加载时进行。
    类的加载是第一次真正用到它的时候（拿类new实例或调用它的静态方法）进行的，
    而这个加载过程需要将 class 文件中构成类的静态和实例方法等类的成员的字节码指令一同加载到内存中，
    而后要为静态域分配存储空间并使用静态块对其进行初始化（如果有的话）。
    在上面例子中，类加载后，所有成员（包括fun和staticfun）的字节码指令均在内存中了，
    随时等待着调用，并且静态域 s 所占用的存储空间也用空引用初始化好了。
 2. 从内存上来看，当第一次调用 getInstance() 方法时会创建此类的唯一实例（所谓的单例出现），
    其实也可以在声明 s 时 new 它的唯一实例，将实例化延后是为了避免类加载后实例使用前内存的浪费。       
 3. 静态方法线程是安全的，所谓线程安不安全是指当多个线程同时操作一个对象（通过调用它的实例方法）
    时是否会造成对象内部状态的破坏，而静态方法不是用来对实例进行操作的，所以一般不用考虑线程同步。
    如果在静态方法中读写文件，此时如果多个线程同时通过调用此静态方法对文件操作肯定会造成文件内容的破坏，
    但这不是线程没同步造成的，因为没有对象的状态被破坏。但可以利用线程同步机制防止上面情况的发生。
 4.从生命周期上来看，静态方法的类会在代码编译的时候就被加载，静态方法中产生的对象，
    会随着静态方法执行完毕而释放掉，而且执行类中的静态方法时，不会实例化静态方法所在的类。
    如果用单例模式, 产生的那一个唯一的实例，会一直在内存中，不会被GC清除的(原因是静态的属性变量不会被GC清除)，
    除非整个应用退出了JVM （所以实际应用中更多的是静态方法中获取单例）
 5. 单例模式是利用唯一的实例保存系统的状态，提供的实例方法也是为了对这个唯一的实例进行操作，
    而静态方法多是一些工具方法，Math 类中的静态方法就是一个典型的例子，
    如果仅仅是想不自己创建类的实例就可以调用到某些方法来完成一定的操作，那完全没必要也不应该使用单例模式。
 6. 从执行效率上看： 静态方法与实例方法，在加载时机和占用内存上，静态方法和实例方法是一样的，
    在类型第一次被使用时加载。调用的速度基本上没有差别。 
    但是从日志打印来看，个人感觉还是静态方法在执行效率上快一点。
 7. 静态方法是面向过程的，而非面向对象的编程思想

```  


## Reference
 - [单例模式](https://www.runoob.com/design-pattern/singleton-pattern.html) 
 



